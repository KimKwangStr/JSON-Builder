name: Build JSON GUI EXE

on:
  workflow_dispatch:
  push:
    branches: [ main ]

jobs:
  build-windows:
    runs-on: windows-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.11'
          cache: 'pip'

      # ⬇️ This step writes app/build_json_gui.py from a heredoc. Only this content has been replaced.
      - name: Create app script via heredoc
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path app | Out-Null
          @'
          #!/usr/bin/env python3
          # -*- coding: utf-8 -*-
          """
          GUI JSON Builder for Clinical Data

          Builds a JSON file that preserves the template's structure:
          - Top-level: list of datasets (one per refid)
          - Inside each dataset: data_sets dict with an Extraction root and child_forms
          - Under each Study and Patient Demographics form (keyed 'spd_XX'):
            - Safety forms
            - Performance (discrete) forms
            - Follow-up Subform (optional)
            - Harms subforms under their matching Safety (via safety_id)

          Inputs (CSV):
            - Study and Patient Demographics.csv      [required]
            - Safety.csv                              [optional]
            - Performance (discrete).csv              [optional]
            - Harms.csv                               [optional]
            - Follow-up Subform.csv                   [optional]
          Template:
            - template.json                           [required]

          Optional:
            - question_types.json  -> {"Adverse Event": "Radio", "Adverse Event Flag": "Checkbox", ...}

          Output:
            - JSON file saved to user-selected location
          Author: M365 Copilot
          """

          import json
          import os
          import sys
          import math
          import tkinter as tk
          from tkinter import filedialog, messagebox
          from datetime import datetime

          # Third-party
          try:
              import pandas as pd
          except ImportError as e:
              raise SystemExit("pandas is required. Please: pip install pandas") from e


          # ----------------------------
          # Helpers
          # ----------------------------

          ID_START = 10000  # starting integer for synthetic dict keys like "10000", "10001", ...

          def next_id(counter):
              """Return next numeric string id and increment counter."""
              val = str(counter["val"])
              counter["val"] += 1
              return val

          def is_nan(x):
              try:
                  return pd.isna(x) or (isinstance(x, float) and math.isnan(x))
              except Exception:
                  return False

          def norm(val):
              """Normalize cell values to strings where appropriate, skip NaN/None."""
              if val is None or is_nan(val):
                  return None
              if isinstance(val, (int, float)) and not isinstance(val, bool):
                  # keep numeric as str to match template 'Text' style
                  return str(val).strip()
              s = str(val).strip()
              return s if s != "" else None

          def make_question(question, value, qtypes):
              """Create a data item for the form."""
              v = norm(value)
              if v is None:
                  return None
              qtype = qtypes.get(question, "Text")
              return {
                  "question": question,
                  "type": qtype,
                  "response": {
                      "answer": "" if qtype == "Text" else v,  # template shows both answer/text
                      "text": v if qtype == "Text" else ""
                  }
              }

          def new_form(form_name, key_str, is_subform, user="json_builder", level=1):
              """Create a new form dict."""
              return {
                  "form": form_name,
                  "level": level,
                  "is_subform": 1 if is_subform else 0,
                  "user": user,
                  "key": key_str,
                  "data": [],
                  "child_forms": {}
              }

          def load_csv_or_none(path):
              if path and os.path.isfile(path):
                  return pd.read_csv(path, dtype=str, keep_default_na=False, na_values=["", "NA", "NaN"])
              return None

          def best_filter(df, **ids):
              """Filter df by any of the provided identifiers that exist as columns."""
              if df is None:
                  return None
              mask = pd.Series([True] * len(df))
              for col, val in ids.items():
                  if col in df.columns:
                      mask = mask & (df[col].astype(str) == str(val))
              return df.loc[mask].copy()

          def to_two(n):
              """Zero-pad numeric strings to 2 digits; fallback to raw."""
              try:
                  return f"{int(str(n)) :02d}"
              except Exception:
                  return str(n)

          def read_json(path):
              with open(path, "r", encoding="utf-8") as f:
                  return json.load(f)

          def write_json(path, obj):
              with open(path, "w", encoding="utf-8") as f:
                  json.dump(obj, f, ensure_ascii=False, indent=2)


          # ----------------------------
          # Core Builder
          # ----------------------------

          def build_json(template_path,
                         spd_path,
                         safety_path=None,
                         perf_disc_path=None,
                         harms_path=None,
                         followup_path=None,
                         qtypes_path=None):

              # Load optional question type overrides
              qtypes = {}
              if qtypes_path and os.path.isfile(qtypes_path):
                  try:
                      qtypes = read_json(qtypes_path)
                  except Exception:
                      qtypes = {}

              # Read CSVs
              spd_df = load_csv_or_none(spd_path)
              if spd_df is None:
                  raise ValueError("Study and Patient Demographics.csv is required and could not be opened.")

              safety_df = load_csv_or_none(safety_path)
              perf_df   = load_csv_or_none(perf_disc_path)
              harms_df  = load_csv_or_none(harms_path)
              fol_df    = load_csv_or_none(followup_path)

              # Required columns
              if "refid" not in spd_df.columns or "spd_id" not in spd_df.columns:
                  raise ValueError("Study and Patient Demographics.csv must include 'refid' and 'spd_id' columns.")

              # Synthetic id counter for dict keys
              counter = {"val": ID_START}

              # Final result is a list (one entry per refid)
              all_datasets = []

              # Group by refid
              for refid, refid_group in spd_df.groupby("refid", sort=False):
                  # Create dataset root following template structure
                  dataset = {
                      "refid": int(refid) if str(refid).isdigit() else refid,
                      "tags": [],
                      "attachments": [],
                      "biblio_string": "",
                      "data_sets": {}
                  }

                  # Root "Extraction" form
                  root_id = next_id(counter)
                  extraction = new_form("Extraction", str(refid), is_subform=False)
                  # Add the single 'Article Identifier' question just like the template
                  extraction["data"].append({
                      "question": "Article Identifier",
                      "type": "Text",
                      "response": {"answer": "", "text": str(refid)}
                  })
                  extraction["child_forms"] = {}
                  dataset["data_sets"][root_id] = extraction

                  # Under Extraction: many SP&D forms (one per spd_id)
                  child_forms_root = extraction["child_forms"]

                  # Iterate spd rows in this refid
                  for _, spd_row in refid_group.iterrows():
                      spd_id_val = spd_row["spd_id"]
                      spd_key = f"spd_{to_two(spd_id_val)}"

                      spd_form_id = next_id(counter)
                      spd_form = new_form("Study and Patient Demographics", spd_key, is_subform=False)

                      # Map spd row columns to questions, skip linking/id columns
                      skip_cols = {"refid", "spd_id", "safety_id", "perf_id", "followup_id"}
                      for col in spd_df.columns:
                          if col in skip_cols:
                              continue
                          item = make_question(col, spd_row[col], qtypes)
                          if item:
                              spd_form["data"].append(item)

                      spd_form["child_forms"] = {}
                      child_forms_root[spd_form_id] = spd_form

                      # SAFETY forms under this SP&D
                      if safety_df is not None and len(safety_df) > 0:
                          safety_rows = best_filter(safety_df, refid=refid, spd_id=spd_id_val)
                          # Fallback to refid-only, if spd_id not present in Safety
                          if safety_rows is None or safety_rows.empty:
                              safety_rows = best_filter(safety_df, refid=refid)

                          for _, srow in (safety_rows or []).iterrows():
                              safety_id_val = srow["safety_id"] if "safety_id" in srow else None
                              # Build a descriptive key if possible
                              ae = srow.get("Adverse Event", "") if isinstance(srow, dict) else srow.get("Adverse Event", "")
                              s_key = f"safety_{safety_id_val}" if safety_id_val else (f"{spd_key}\\n{ae}" if ae else f"{spd_key}\\nSafety")

                              safety_form_id = next_id(counter)
                              safety_form = new_form("Safety", s_key, is_subform=False)

                              for col in safety_rows.columns:
                                  if col in skip_cols:
                                      continue
                                  item = make_question(col, srow[col], qtypes)
                                  if item:
                                      safety_form["data"].append(item)

                              # HARMS subform(s) matched by safety_id
                              safety_form["child_forms"] = {}
                              if harms_df is not None and safety_id_val and "safety_id" in harms_df.columns:
                                  harms_rows = harms_df.loc[harms_df["safety_id"] == str(safety_id_val)]
                                  for _, hrow in harms_rows.iterrows():
                                      harms_form_id = next_id(counter)
                                      harms_key = f"{s_key}\\nHarms"
                                      harms_form = new_form("Harms", harms_key, is_subform=True)

                                      for col in harms_rows.columns:
                                          if col in skip_cols:
                                              continue
                                          item = make_question(col, hrow[col], qtypes)
                                          if item:
                                              harms_form["data"].append(item)

                                      safety_form["child_forms"][harms_form_id] = harms_form

                              spd_form["child_forms"][safety_form_id] = safety_form

                      # PERFORMANCE (discrete) forms
                      if perf_df is not None and len(perf_df) > 0:
                          perf_rows = best_filter(perf_df, refid=refid, spd_id=spd_id_val)
                          if perf_rows is None or perf_rows.empty:
                              perf_rows = best_filter(perf_df, refid=refid)

                          for _, prow in (perf_rows or []).iterrows():
                              endpoint = prow.get("Perf Discrete Endpoint") if "Perf Discrete Endpoint" in perf_rows.columns else None
                              timept = prow.get("Perf Discrete Time Point") if "Perf Discrete Time Point" in perf_rows.columns else None
                              p_key = f"{spd_key}\\n{endpoint or 'Performance'}" + (f"-{timept}" if timept else "")

                              perf_form_id = next_id(counter)
                              perf_form = new_form("Performance (discrete)", p_key, is_subform=False)

                              for col in perf_rows.columns:
                                  if col in skip_cols:
                                      continue
                                  item = make_question(col, prow[col], qtypes)
                                  if item:
                                      perf_form["data"].append(item)

                              spd_form["child_forms"][perf_form_id] = perf_form

                      # FOLLOW-UP subform (optional)
                      if fol_df is not None and len(fol_df) > 0:
                          fol_rows = best_filter(fol_df, refid=refid, spd_id=spd_id_val)
                          if fol_rows is not None and not fol_rows.empty:
                              for _, frow in fol_rows.iterrows():
                                  fol_id = next_id(counter)
                                  fu_form = new_form("Follow-up Subform", f"{spd_key}\\nFollow-up", is_subform=True)
                                  for col in fol_rows.columns:
                                      if col in skip_cols:
                                          continue
                                      item = make_question(col, frow[col], qtypes)
                                      if item:
                                          fu_form["data"].append(item)
                                  spd_form["child_forms"][fol_id] = fu_form

                  all_datasets.append(dataset)

              # Validate template file is readable (we don’t clone its contents, we mirror its structure/keys)
              if not template_path or not os.path.isfile(template_path):
                  raise ValueError("template.json path is invalid or missing.")

              # Save
              ts = datetime.now().strftime("%Y%m%d_%H%M%S")
              default_out = f"output_{ts}.json"
              return all_datasets, default_out


          # ----------------------------
          # GUI
          # ----------------------------

          class App(tk.Tk):
              def __init__(self):
                  super().__init__()
                  self.title("JSON Builder")
                  self.geometry("770x420")

                  self.template_var = tk.StringVar()
                  self.spd_var = tk.StringVar()
                  self.safety_var = tk.StringVar()
                  self.perf_var = tk.StringVar()
                  self.harms_var = tk.StringVar()
                  self.followup_var = tk.StringVar()
                  self.qtypes_var = tk.StringVar()
                  self.output_var = tk.StringVar()

                  row = 0
                  self._row("Template JSON", self.template_var, row); row += 1
                  self._row("Study and Patient Demographics.csv", self.spd_var, row); row += 1
                  self._row("Safety.csv (optional)", self.safety_var, row); row += 1
                  self._row("Performance (discrete).csv (optional)", self.perf_var, row); row += 1
                  self._row("Harms.csv (optional)", self.harms_var, row); row += 1
                  self._row("Follow-up Subform.csv (optional)", self.followup_var, row); row += 1
                  self._row("question_types.json (optional)", self.qtypes_var, row); row += 1
                  self._row("Output JSON", self.output_var, row, save=True); row += 1

                  self.status = tk.StringVar(value="Ready")
                  tk.Label(self, textvariable=self.status, anchor="w").grid(row=row, column=0, columnspan=3, sticky="we", padx=10, pady=(10,0))
                  row += 1

                  build_btn = tk.Button(self, text="Build JSON", command=self.on_build, bg="#0067b8", fg="white")
                  build_btn.grid(row=row, column=0, padx=10, pady=10, sticky="w")

              def _row(self, label, var, row, save=False):
                  tk.Label(self, text=label, width=36, anchor="w").grid(row=row, column=0, padx=10, pady=6, sticky="w")
                  tk.Entry(self, textvariable=var, width=68).grid(row=row, column=1, padx=6, pady=6)
                  browse = tk.Button(self, text="Browse...", command=lambda: self._browse(var, save))
                  browse.grid(row=row, column=2, padx=6, pady=6)

              def _browse(self, var, save):
                  if save:
                      path = filedialog.asksaveasfilename(
                          title="Save output JSON",
                          defaultextension=".json",
                          filetypes=[("JSON files","*.json"), ("All files","*.*")]
                      )
                  else:
                      path = filedialog.askopenfilename(
                          title="Select file",
                          filetypes=[("All files","*.*")]
                      )
                  if path:
                      var.set(path)

              def on_build(self):
                  try:
                      self.status.set("Building...")
                      self.update_idletasks()

                      all_datasets, suggested_name = build_json(
                          template_path=self.template_var.get(),
                          spd_path=self.spd_var.get(),
                          safety_path=self.safety_var.get() or None,
                          perf_disc_path=self.perf_var.get() or None,
                          harms_path=self.harms_var.get() or None,
                          followup_path=self.followup_var.get() or None,
                          qtypes_path=self.qtypes_var.get() or None
                      )

                      out_path = self.output_var.get().strip() or suggested_name
                      write_json(out_path, all_datasets)
                      self.status.set(f"Success → {out_path}")
                      messagebox.showinfo("Done", f"JSON written to:\n{out_path}")

                  except Exception as ex:
                      self.status.set("Error")
                      messagebox.showerror("Error", str(ex))


          def main():
              app = App()
              app.mainloop()

          if __name__ == "__main__":
              main()
          '@ | Set-Content -NoNewline -Encoding UTF8 app/build_json_gui.py

      - name: Install dependencies
        shell: pwsh
        run: |
          python -m pip install --upgrade pip
          if (Test-Path "requirements.txt") {
            pip install -r requirements.txt
          } else {
            pip install pandas
          }
          pip install pyinstaller

      - name: Build EXE with PyInstaller
        shell: pwsh
        run: |
          pyinstaller --noconfirm --onefile --name json-builder `
            app/build_json_gui.py

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: json-builder-exe
          path: dist/json-builder.exe
